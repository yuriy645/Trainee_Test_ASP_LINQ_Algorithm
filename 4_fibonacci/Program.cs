using System;

namespace _4_fibonacci
{//Write a method to find the nth Fibonacci number in the Fibonacci sequence both iterative and recursive ways.
 //Describe the time and space complexity (O) of each implementation.
    class Program
    {
        //Метод фибоначи на цикле 
        //При вызове этого метода, значения полей помещаются во фрейм стека. После чего процессор выполняет метод, следуя по последовательности команд в обычном режиме.
        public static int fibCycle(int x)
        {
            int a1 = 0, a2 = 1, a3 = 1;     //инициализация первых 3-х членов
            for (int i = 1; i < x; i++) 
            {
                a3 = a1 + a2; //сумма из двух предыдущих
                a1 = a2;      //для следующей итерации нужно "сдвинуть" a1 и a2 вправо по ряду
                a2 = a3;      
            }
            return a3;
        }


        //Метод фибоначи рекурсией
        // Простой рекурсивный метод сразу тоже кладет свои значения в выделенный фрейм стека, но пытается первым делом вычислить последний член ряда,
        // а когда это не получается, то он занимает ещё 2 фрейма стека ( для вызовов fibRec(x - 1) и fibRec(x - 2) ), чтобы вычислить 2 предыдущих члена.
        // А если и это не получается, то каждый из этих двух fibRec занимает в стеке еще по 2 фрейма.
        // Тут выходит, что мы еще не прошлись по трем членам, а метод fibRec занял стек уже 7 раз!  Дальше- хуже. Рекурсивый метод именно в применении для фибоначчи не только
        // тиражирует данные в стеке, но и делает это с особым "усердием" из-за двойного перевызова. Что, вызывает не пустой вопрос, на какую длину
        // ряда хватит объема стека 1МБ и оправдан ли риск получить необрабатываемое исключение в приложении.
        // В дополнение можно сказать только то, что каждый лишний выделенный фрейм в стеке соответствует лишнему количеству раз, которое процессор выполнит метод fibRec,
        // что еще раз сокращает время выполнения.
        // В общем, метод ужасный для реального применения, но тут явно напрашивается решение, как его усовершенствовать.
        public static int fibRec(int x)
        {
            if (x == 0) return 0;
            if (x == 1) return 1;

            else
            {
                return fibRec(x - 1) + fibRec(x - 2);
            }
        }


        //Метод Фибоначи с мемоизацией
        // Подход заключается в том, чтобы сразу запоминать вычисленные члены при рекурсивном методе. В дальнейшем, если член ряда с таким номером (индексом) уже существует, то он больше
        // не вычисляется. Количество значений в массиве
        // равно количеству членов ряда и располагаются они на куче.
        public static int fibMem(int x)
        {
            int[] knownFib = new int[1000];

            if (knownFib[x] != 0)   //если туда внесено какое-то значение, 
            {
                return knownFib[x]; //то использовать его
            }
            if (x == 0) return 0;
            if (x == 1) return 1;
            
            return knownFib[x] = fibMem(x - 1) + fibMem(x - 2); //перед выводом результата, заносим его в ячейку массива  (с номером входного значения)
        }

        static void Main(string[] args)
        {
            int b = 20;
            Console.WriteLine("Ряд Фибоначи цикл: ");
            for (int j = 1; j <= b; j++)             
            {
                Console.Write(fibCycle(j) + " ");
            }
            Console.WriteLine();

            Console.WriteLine("Ряд Фибоначи рекурсия: ");
            for (int j = 1; j <= b; j++)                 
            {
                Console.Write(fibRec(j) + " ");
            }
            Console.WriteLine();

            Console.WriteLine("Ряд Фибоначи мемоизация:");
            for (int j = 1; j <= b; j++)                   
            {
                Console.Write(fibMem(j) + " ");
            }
        }
    }
}
